# 📚 PDF版面还原神器！将双栏学术论文转换为单栏Markdown实战（上）

✨你好，我是筱可，欢迎来到「筱可AI研习社」！

🚀 标签关键词：| AI实战派开发者 | 技术成长陪伴者 | 文档智能处理探索者 |

上一次，我们体验了如何运行PaddleDetection进行版面分析。今天，我们更进一步，要实现将双栏或单栏PDF文档转换成单栏Markdown格式！
![版面分析可视化示例](https://files.mdnice.com/user/90137/8dfa2e7f-141d-4368-919e-726c02492c01.png)
**本次主题是：**

**基于版面检测结果构建PDF转Markdown框架**

话不多说，我们开始吧！！！

## 📋 通过本文你将收获

- 🔍 掌握版面检测结果的处理流程与框架设计
- 🧩 学习如何处理双栏论文的元素顺序排列问题
- 🛠️ 了解PDF转Markdown代码框架
- 🎯 了解不同类型元素（文本、表格、图片等）的处理方法

## 🚀 下篇文章预告

我们将进一步集成OCR、表格识别和图表理解等多个模型，实现完整的PDF智能转换系统。

> tips:
> 版面检测只是第一步，要实现完整的PDF转Markdown，我们还需要集成OCR模型来识别文本内容，表格识别模型来处理表格结构，甚至是图表理解模型来解析图表内容。今天我们先搭建基础框架，为后续工作打好基础！

## 🌟 一、版面检测后的处理挑战

上次我们成功运行了PaddleDetection的版面分析模型，得到了文档中各个元素（文本、标题、表格、图片等）的位置信息。但这仅仅是第一步，接下来我们需要解决几个关键问题：

### 1. 双栏排序问题

学术论文通常采用双栏布局，如果简单按照从上到下的顺序处理元素，就会混乱不堪。我们需要：

- ✅ 正确识别左右两栏
- ✅ 先处理左栏内容，再处理右栏内容
- ✅ 每栏内部按照从上到下的顺序排列

**为什么这个问题很重要？**

一般的PDF解析工具如PyMuPDF或pdfplumber通常采用"从上至下，从左至右"的方式提取文本，这对双栏学术论文来说是灾难性的 — 它会先提取左栏顶部的一部分，然后提取右栏顶部，然后又回到左栏，导致阅读顺序完全混乱。

**常见的解决策略对比：**

1. **简单基于Y坐标排序**：只考虑元素顶部Y坐标，从上到下排序。
   - 优点：实现简单
   - 缺点：双栏布局会被完全打乱，左右栏内容交错出现

2. **基于页面分区**：先人为将页面分为左右两栏，然后按栏处理。
   - 优点：思路清晰
   - 缺点：无法处理跨栏元素，对不规则版面效果差

3. **我们的方案：基于覆盖比例判断**：计算元素在左右两侧的覆盖比例，动态判断元素归属。
   - 优点：能智能处理跨栏元素，适应不同宽度的栏
   - 缺点：实现稍复杂，需要精细调整阈值

### 2. 不同元素类型的处理方式

- 📄 **文本**：需要保留段落结构
- 📊 **表格**：需要提取表格内容并转换为Markdown表格格式
- 📈 **图表**：需要提取图像并在Markdown中引用
- 📑 **公式**：需要特殊处理成数学公式

**为什么每种元素需要不同的处理策略？**

不同类型的文档元素在语义、表现形式和转换要求上有本质差异。例如：

- 表格需要保持行列结构，简单的OCR会丢失这种结构信息
- 公式如果以纯文本方式处理会丢失数学含义，需要特殊的数学公式识别
- 图表内的文本和图形需要综合理解，单一OCR模型无法完整解析

**传统文档解析VS我们的多元素处理器方案：**

| 传统方法 | 我们的方案 | 对比优势 |
|---------|----------|----------|
| 所有内容统一OCR | 为不同元素类型设计专门处理器 | 保留更多原始语义和结构 |
| 图片内容直接丢失 | 提取图片并在MD文件中引用 | 保留完整图像信息 |
| 表格结构被破坏 | 专门的表格处理引擎 | 保持表格行列关系 |
| 公式变成普通文本 | 数学公式专门处理 | 保留公式的可编辑性 |

### 3. 元素提取与输出

- 🖼️ 如何从原始图像中提取每个元素的内容
- 📝 如何生成符合要求的Markdown文件
- 🔗 如何处理图像引用和路径问题

**为什么元素提取很关键？**

版面分析模型只告诉我们"这里有一个表格"或"那里有一张图"，但没有给我们表格的内容或图像的像素值。我们需要：

1. 从原始PDF或其渲染图像中裁剪出元素区域
2. 对每种元素类型应用适当的识别模型
3. 构建合理的文件组织结构以支持Markdown中的引用

**现有的替代方案分析：**

- **PDF直接转换工具**（如pdf2md）：无法正确处理复杂布局
- **OCR+规则处理**：难以准确区分不同元素类型
- **我们的方案**：先版面分析，后多模型处理，保留原始语义和结构

## 🏗️ 二、整体框架设计

我们设计了一个模块化的处理框架，包含以下组件：

### 1. DocumentElementProcessor类

这是整个框架的核心，负责：

- 读取版面分析的JSON结果
- 对元素进行排序
- 调用适当的元素处理器
- 生成最终的Markdown文件

```python
class DocumentElementProcessor:
    def __init__(self, output_dir="output", images_dir="images", font_path=None):
        """初始化文档元素处理器"""
        # ...初始化代码...
        
    def process_document(self, layout_json_path, visualization_output_path, markdown_filename):
        """处理文档版面分析结果"""
        # 1. 读取JSON
        # 2. 对元素排序
        # 3. 生成可视化结果
        # 4. 生成Markdown文件
```

**为什么选择这种设计模式？**

我们采用了单一责任原则，使得DocumentElementProcessor成为一个「协调者」而不是「全能选手」。这样设计的优势在于：

1. **关注点分离**：主类只负责流程控制和元素协调，不关心具体元素处理细节
2. **易于扩展**：增加新元素类型只需添加新的处理器，无需修改主流程
3. **简化测试**：各模块可独立测试，减少集成复杂度

**与其他架构方案的对比：**

| 架构方案 | 优点 | 缺点 |
|---------|------|------|
| 单体大类 | 实现简单，调用方便 | 代码臃肿，难以维护 |
| 全静态函数 | 无需实例化，直接调用 | 难以管理状态，测试复杂 |
| **我们的组件化设计** | 职责清晰，易于扩展与测试 | 初始实现稍复杂 |

### 2. 元素处理器工厂

使用工厂模式创建不同类型的元素处理器：

```python
class ElementProcessorFactory:
    @staticmethod
    def create_processor(element, index, document_image_path=None,
                        output_dir=".", images_dir="images"):
        """创建合适的元素处理器"""
        label = element["label"]
        
        # 根据元素类型创建相应的处理器
        if label in ["doc_title", "paragraph_title", "table_title", ...]:
            return TitleProcessor(...)
        elif label in ["text", "abstract"]:
            return TextProcessor(...)
        # ...其他元素类型...
```

**为什么使用工厂模式而非直接实例化？**

工厂模式在这里提供了几个关键优势：

1. **封装创建逻辑**：客户端代码不需要知道如何创建元素处理器，也不需要了解处理器的构造细节
2. **集中管理元素类型映射**：所有元素类型与处理器的映射关系集中在一处，便于维护
3. **简化未来扩展**：当支持新元素类型时，只需在工厂类中添加判断逻辑
4. **提供默认行为**：对于未知元素类型可以提供默认处理器，增强系统健壮性

**如果不用工厂模式会怎样？**

如果在主流程中使用大量if-else直接创建处理器实例，会导致：

- 代码重复，主流程变得臃肿
- 每增加一种元素类型都需要修改主流程代码
- 测试复杂度增加，难以进行单元测试

### 3. 具体元素处理器

为每种类型的元素实现专门的处理器：

- `TitleProcessor`: 处理各级标题
- `TextProcessor`: 处理文本段落
- `ImageProcessor`: 处理图像和图表
- `TableProcessor`: 处理表格
- `FormulaProcessor`: 处理数学公式

**为什么使用继承体系而非单独的函数？**

我们使用了基于继承的面向对象设计，这与简单的函数式处理相比有几个显著优势：

1. **共享基础行为**：所有处理器共享基类的基础功能，如元素图像提取
2. **强制接口一致性**：通过抽象方法确保每个处理器都实现了必要方法
3. **保持状态连贯**：处理器可以在多个方法之间共享状态，无需频繁传递参数
4. **支持多态调用**：主程序不需要关心具体处理器类型，统一通过基类接口调用

**元素处理器的设计决策：**

我们为每个元素处理器设计了统一的接口`to_markdown()`，但内部实现各不相同：

- **TitleProcessor**：根据标题级别生成不同数量的`#`符号
- **ImageProcessor**：提取图片并生成Markdown图片引用
- **TableProcessor**：识别表格结构并转换为Markdown表格格式
- **FormulaProcessor**：将公式转换为LaTeX格式并用`$$`包裹

这种设计实现了"相同接口，不同行为"的多态原则，使得主程序可以统一调用处理器的`to_markdown()`方法，而不关心具体元素类型。

## 🔄 三、双栏布局排序算法

双栏布局的排序是本框架的核心创新点之一。我们的算法基于以下思路：

```python
def _sort_elements(self, elements, page_width=None):
    """
    对元素按照左右栏进行排序
    """
    # 如果未提供页面宽度，则从元素坐标推断
    if page_width is None:
        page_width = max([elem["coordinate"][2] for elem in valid_elements])
    
    # 页面中心点
    page_center_x = page_width / 2
    
    # 分左右栏
    left_column = []
    right_column = []
    
    for elem in valid_elements:
        x1, _, x2, _ = elem["coordinate"]
        elem_width = x2 - x1
        
        # 计算元素在页面左侧和右侧的部分
        left_part_width = max(0, min(x2, page_center_x) - x1)
        right_part_width = max(0, x2 - max(x1, page_center_x))
        
        # 计算左右覆盖比例
        left_ratio = left_part_width / elem_width if elem_width > 0 else 0
        right_ratio = right_part_width / elem_width if elem_width > 0 else 0
        
        # 根据覆盖比例判断元素归属
        if left_ratio >= 0.9:  # 90%以上在左侧
            left_column.append(elem)
        elif right_ratio >= 0.9:  # 90%以上在右侧
            right_column.append(elem)
        # ...其他情况...
    
    # 各栏内部按垂直位置排序
    left_column.sort(key=lambda e: e["coordinate"][1])
    right_column.sort(key=lambda e: e["coordinate"][1])
    
    # 合并结果：先左栏，后右栏
    return left_column + right_column
```

这个算法的巧妙之处在于：

1. 计算每个元素在页面左右两侧的覆盖比例
2. 根据覆盖比例确定元素属于左栏还是右栏
3. 对于跨栏元素（如标题、图表等），特殊处理
4. 最后按照"先左后右，每栏从上到下"的顺序输出

**为什么不用简单的几何分区方法？**

在处理双栏文档时，最直观的方法是简单地以页面中线为界，将元素分为左右两栏。然而，这种方法存在几个严重问题：

1. **无法处理跨栏元素**：论文中的标题、大图表等经常横跨两栏
2. **对不规则版面失效**：有些论文的栏宽不等，或者有特殊布局
3. **无法应对元素倾斜或错位**：实际扫描文档中元素位置可能有偏差

**几种双栏排序方法对比：**

| 排序方法 | 处理原理 | 优点 | 缺点 |
|---------|---------|------|------|
| 简单中线分区 | 以页面中线为界，左右区分 | 实现简单 | 无法处理跨栏元素 |
| 基于Y坐标分行 | 检测元素垂直重叠，分行处理 | 适应不规则版面 | 计算复杂，对密集元素效果不佳 |
| **我们的覆盖比例算法** | 计算元素在左右两侧的覆盖占比 | 智能处理跨栏元素，适应不同宽度的栏 | 需要精细调整阈值参数 |

**阈值选择的考量：**

我们选择90%作为归属判定阈值是经过多次实验得出的最佳值：

- 阈值过高（如99%）：很多轻微偏离的元素将无法被正确分类
- 阈值过低（如70%）：可能导致窄元素被错误归类
- 90%的阈值在大多数文档上取得了最佳平衡

**处理特殊情况**：

代码中还包含对跨栏元素的特殊处理：

```python
elif left_ratio > 0.3 and right_ratio > 0.3:  # 跨中线，两侧各占30%以上
    left_column.append(elem)  # 归为左栏
```

这确保了标题等跨栏元素被正确处理，通常我们将它们放在左栏（即先处理），这样在阅读时逻辑更通顺。

## 📷 四、元素提取与可视化

### 1. 元素可视化

为了直观展示版面分析结果，我们实现了可视化功能：

```python
def _visualize_elements(self, image_path, elements, output_path):
    """将元素框可视化在原始图像上"""
    # 1. 读取原始图像
    # 2. 在图像上绘制每个元素的边界框
    # 3. 添加元素类型和序号标签
    # 4. 保存结果图像
```

效果如下：
![](https://oss-liuchengtu.hudunsoft.com/userimg/c1/c1a9d21c60ad19dbd799f9768f2edb46.png)

**为什么可视化很重要？**

可视化不仅仅是一个"好看"的功能，它在整个开发和使用过程中起到关键作用：

1. **开发调试**：直观展示模型检测结果，快速发现问题
2. **排序验证**：确认元素排序算法是否正确分配了左右栏
3. **用户理解**：帮助用户理解转换过程，增强信任感
4. **质量评估**：方便评估版面分析质量，针对性优化

### 2. 元素图像提取

对于表格、图表等元素，我们需要从原始图像中提取其内容：

```python
def extract_element_image(self, filename):
    """从原始文档图像中提取元素图像"""
    # ...提取代码...
    # 1. 读取原始图像
    # 2. 根据元素坐标裁剪
    # 3. 保存为独立图片文件
    # 4. 返回保存路径供Markdown引用
```

**我们解决方案的特点：**

1. **统一接口**：在基类中实现通用提取逻辑，子类可以根据需要重写
2. **路径结构**：设计了清晰的目录结构，确保Markdown引用正确
3. **错误处理**：完善的异常捕获，确保单个元素处理失败不影响整体流程
4. **可配置性**：通过参数控制输出目录等，便于集成到不同环境

**与其他提取方法的对比：**

一些同类工具采用基于PDF解析的方法提取元素（如PyMuPDF的提取功能）。相比之下，我们基于图像的提取方法有以下优势：

1. **适用范围更广**：可处理扫描PDF或直接来自图像的文档
2. **保留视觉细节**：完整保留了元素的视觉表现，包括格式、字体等
3. **不依赖PDF结构**：许多PDF内部结构混乱，基于解析的方法可能失效

## 🔧 五、如何使用这个框架

使用我们的框架非常简单，只需要几行代码：

```python
# 创建处理器
processor = DocumentElementProcessor(output_dir="output", images_dir="images")

# 处理文档
processor.process_document(
    layout_json_path="res.json",  # 版面分析结果
    visualization_output_path="visualization_result.png",  # 可视化输出
    markdown_filename="document.md"  # 输出的Markdown文件名
)
```

这样就能得到一个包含完整文档内容的Markdown文件，以及可视化的版面分析结果。

## 📐 六、测试与验证

为了确保我们的框架正常工作，我们编写了测试脚本：

```python
def test_document_processing():
    """测试文档处理功能，特别关注输出文件和图片路径引用"""
    
    # 设置明确的输出路径
    output_dir = "output"
    images_dir = "images"
    markdown_path = "test.md"
    visualization_path = "visualization_test.png"
    
    # 创建处理器并执行流程
    processor = DocumentElementProcessor(
        output_dir=output_dir,
        images_dir=images_dir
    )
    
    processor.process_document(
        layout_json_path,
        visualization_path,
        markdown_path
    )
    
    # 检查输出文件是否正确生成
    # 检查Markdown中的图片引用是否有效
```

**为什么测试如此重要？**

在文档处理这类复杂系统中，测试尤为关键，因为：

1. **多模块集成**：多个组件协同工作，任一组件失效可能导致整体失败
2. **边缘情况多**：各种不规则布局、特殊元素可能导致意外错误
3. **输出质量要求高**：最终Markdown文件必须保持良好的格式和正确的引用
4. **路径依赖性**：图像引用涉及相对路径，必须在不同环境下正确工作

**我们的测试策略：**

我们采用多层次测试策略，确保框架的健壮性：

1. **单元测试**：测试每个处理器和关键函数的独立功能
2. **集成测试**：验证多个组件组合使用的正确性
3. **样本文档测试**：使用代表性文档验证整体工作流
4. **边缘情况测试**：特殊布局、空元素、异常值等测试

**测试重点关注：**

- 元素排序算法的正确性
- 图像提取和保存的准确性
- Markdown文件中的图片引用是否有效
- 不同元素类型处理的正确性
- 异常情况的错误处理

## 💡 七、后续工作

目前我们的框架只处理了版面结构，还没有实际的文本内容。接下来我们将：

1. 集成OCR模型，识别每个文本元素的内容
2. 集成表格识别模型，提取表格结构与数据
3. 使用图表理解模型，分析图表内容
4. 优化Markdown生成，使最终结果更美观

**为什么需要多模型集成？**

单一模型难以应对文档解析的全部挑战，多模型集成能有效解决这一问题：

1. **专精原则**：不同模型专注于不同任务，发挥各自优势
   - 版面分析模型擅长区分元素类型和位置
   - OCR模型专注于精准文字识别
   - 表格识别模型保留表格结构
   - 图表理解模型提取图表数据和含义

2. **性能平衡**：可以为不同任务选择最适合的模型
   - 高精度但速度较慢的模型用于关键任务（如表格结构识别）
   - 轻量级模型用于大量简单任务（如普通文本识别）
   - 预训练模型与针对特定领域微调模型的组合

3. **错误隔离**：单个模型失效不会导致整个流程崩溃
   - 模块化设计保证了各处理环节相对独立
   - 完善的异常处理机制确保单点故障不影响整体
   - 降级处理策略提供备选方案（如表格识别失败时使用图像方式保存）

**对比单模型与多模型解决方案：**

| 方面 | 单一大型模型方案 | 我们的多模型集成方案 | 优势分析 |
|------|---------------|-------------------|--------|
| 精度 | 各任务精度参差不齐 | 每个任务都使用专精模型 | 各元素类型处理更精准 |
| 计算资源 | 单次大量消耗 | 按需分配，可并行处理 | 在普通硬件上也能高效运行 |
| 可维护性 | 黑盒难以调试 | 各模块独立优化 | 问题定位与修复更简单 |
| 可扩展性 | 需重新训练整体 | 可单独升级各模块 | 技术迭代成本低 |

**多模型集成的技术挑战：**

实现多模型集成并非易事，我们将在下篇文章中详细讨论如何解决这些挑战：

1. **模型间通信**：如何高效传递中间结果，确保各模型协同工作
2. **结果融合**：如何整合不同模型的输出，形成一致的文档表示
3. **推理优化**：如何在有限资源下平衡各模型的计算需求
4. **错误处理**：如何构建鲁棒的错误处理机制，避免级联失败

## 📋 总结与展望

### 技术全景图

我们已经构建了一个基于版面分析的文档处理框架，包含以下核心技术点：

- 🔍 **模块化架构**：基于单一责任原则的组件设计，确保系统可扩展性
- 🧩 **智能排序算法**：基于覆盖比例的双栏布局排序，解决学术文档特有难题
- 🖼️ **元素可视化技术**：支持中文标注的检测结果可视化，方便调试和展示
- 📐 **类型化处理器**：针对不同元素类型的专用处理器，保留原始语义
- 🔧 **工厂模式设计**：灵活创建和管理不同类型的元素处理器，简化扩展

这些技术点共同构成了一个强大而灵活的基础框架，为后续深入开发奠定了坚实基础。

### 技术实现深度分析

**1. 为什么基于图像处理比直接解析PDF更优？**

许多读者可能会问：为什么不直接使用PDF解析库获取内容和结构？原因在于：

- PDF内部结构千差万别，缺乏统一标准实现，特别是扫描PDF完全无法解析
- 学术论文通常使用复杂排版，简单解析会丢失重要的版面信息
- 基于图像的方法具有更好的通用性，同样的流程可以处理图片、扫描文档等多种格式

**2. 双栏排序算法的优化空间**

我们的覆盖比例算法虽然有效，但仍有进一步优化空间：

- **自适应分栏**：不假设页面仅有两栏，而是根据元素分布自动检测栏数
- **版面聚类**：使用聚类算法自动分组元素，适应更复杂的非规则版面
- **元素关系分析**：考虑元素间的逻辑关联，如标题与其下文本的从属关系

**3. 处理器设计的进阶考量**

针对复杂场景，处理器可以进一步增强：

- **上下文感知**：处理器不仅考虑当前元素，还考虑周围元素的信息
- **状态保持**：在处理多页文档时，维护跨页的状态信息
- **分级质量控制**：根据输入质量动态调整处理策略，平衡速度与精度

### 学习进阶路径

对于想深入学习文档智能处理的开发者，我推荐以下进阶路径：

1. **理论基础**：深入学习计算机视觉和自然语言处理的基础理论
2. **技术栈拓展**：熟悉OCR技术、表格结构分析、图表理解等专项技术
3. **工程实践**：从小型项目开始，逐步构建完整的文档理解系统
4. **领域知识**：了解特定领域（如学术、法律、金融）的文档特点和要求

## 🚀 动手实践挑战

为了帮助大家巩固学习，我准备了几个实践挑战：

### 挑战1：优化双栏排序算法

改进我们的排序算法，使其能够：

- 处理三栏或不规则多栏布局
- 更智能地处理跨栏元素
- 考虑元素间的逻辑关联（如标题与段落的归属关系）

### 挑战2：提前将飞桨系列的模型集成进去

完成当前框架部分没有完成的集成任务：

- 添加表格识别模型
- 添加公式识别模型

## 💬 互动交流环节

1. **你在处理PDF文档时面临的最大挑战是什么？** 特别是处理学术论文或复杂排版文档时。

2. **你认为我们的框架还可以如何改进？** 有哪些功能你希望在下一版本中看到？

3. **你更倾向于使用哪种元素排序策略？** 是基于简单的几何位置，还是考虑更复杂的语义关联？

4. **在文档智能处理领域，你最关注哪方面的进展？** 是OCR技术，表格识别，还是多模态理解？

5. **如果将这个框架应用到你的工作或学习中，你会用它处理什么类型的文档？** 分享一下你的应用场景。

**你的反馈将直接影响我们下一步的开发方向！每条评论我都会认真阅读并回复。**

> 💡 **专家提示**：文档处理是一个复杂的领域，没有放之四海而皆准的解决方案。关键是理解自己的具体需求，选择合适的技术路线，并不断迭代优化。

## 📣 下期预告

在《PDF版面还原神器（下）》中，我们将：

1. **集成OCR技术**：将PaddleOCR融入我们的框架，实现文本内容的精准识别
2. **实现表格结构提取**：使用表格识别模型重建表格结构，保留行列关系
3. **图表理解与重构**：探索如何智能解析图表内容，提取数据并生成可编辑格式
4. **全流程系统集成**：将所有组件整合成一个完整的PDF转Markdown系统

**敬请期待我们的下一篇文章，我们将共同完成这个实用工具的开发！**

### 💗立即行动

**1. 点赞、收藏、关注，顺手分享给可能感兴趣的朋友。  
2. 为账号加个星标或特别关注，获取更多精彩内容。  
3. 以这篇文章为灵感，整理一份属于自己的笔记。**

### 🚗行动召唤

📢"与其等着AI改变世界，不如自己参与变革！在这儿，让AI成为你弯道超车的秘密武器。"

**（系统检测发现，您具有极强的文档处理基础，动动小手，便可轻易超越作者，赶快开始吧！）**

---
🙋♂️ 入群交流 & 资料领取  

1️⃣ **入群方式**

- 公众号菜单点击「社群」，扫码直接入群

- 回复关键词「入群」「加群」等，添加作者微信人工邀请

2️⃣ **资料领取**

- 入群后查看群公告，获取学习资源

- 回复「资料」至公众号，自动发送网盘链接（定期更新）
 
- 公众号菜单点击「资料领取」

## 📓附录

### 往期文章

- [打造RAG应用必知：BM25算法实战解析，让你不落人后](https://mp.weixin.qq.com/s/kt4_PC97WbeQzjRVXSIuZA)

- [手把手教程：用MinerU构建自动化文档转换流水线](https://mp.weixin.qq.com/s/DkaqxcgrEgj9YhHnN_NDHw)

- [飞桨版面检测分析的命令看不懂？恭喜！您已获得 argparse 入门手册一本，快快学起来吧！](http://mp.weixin.qq.com/s/5b8PqqViSpvgMjpfJqOxCQ?token=1077873472&lang=zh_CN)

- [大模型应用极简开发快速入门](http://mp.weixin.qq.com/s/kHeVK6hManVUaci2p-42GQ)

- [基于 Streamlit 和 DeepSeek 的智能文档助手开发实战指南
](https://mp.weixin.qq.com/s/38BcsiGF1WhKx4DaA-8l0A)

- [告别低效沟通：提示词框架助你玩转deepseek](https://mp.weixin.qq.com/s/QRIQf2cg5i6R_aRhSwdqMg?)
